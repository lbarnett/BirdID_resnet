"""
predict.py - Given a single image, or folder of images, make predictions.

Given a single file and a previously trained model, predict the category
for the image. If provided with a folder of image files, predict categories
for all images, and copy them to a folder structure by category.
"""

from __future__ import print_function
import argparse
import importlib
import re
import os
import shutil


import keras
# from keras.preprocessing.image import load_img
# from keras.preprocessing.image import img_to_array
# from keras.applications.imagenet_utils import decode_predictions
# from keras.preprocessing.image import ImageDataGenerator
# from keras.models import Sequential
# from keras.layers import Conv2D, MaxPooling2D
# from keras.layers import Activation, Dropout, Flatten, Dense
from keras import backend as K
# from PIL import Image
# import binary_3conv
# import matplotlib.pyplot as plt
import numpy as np
from scipy.misc import imread


from utils.imgprocessing import meanstd, center_crop, resize_and_crop
# from utils.imgloader import _copy_data


def predict_img(im_filename, model, data_module, categories,
                positive_id_threshold):
    """
    Make a prediction on the category of a single image.

    Using a previously trained Keras model, make a prediction
    on the category of a single image. Constants used to preprocess
    the image age provided in data_module. The list of possible
    categories, in the order predictions should be made, are provided
    in categories arg.

    Args:
    im_filename: path to file to classify.
    model: model to use for prediction.
    data_module: data module used for training model
    categories: list of category names.

    Returns:
    Predicted category, category name, probability of prediction.

    """
    base, fn = os.path.split(im_filename)
    # print('Classifying', fn)
    im = imread(im_filename, mode='RGB')
    # Display image
    # plt.imshow(im)
    # plt.show()

    resize_dim = data_module.LOAD_DIM  # adjust as needed
    crop_dim = data_module.CROP_DIM    # adjust as needed
    mean = data_module.mean
    std = data_module.std

    # See utils/datagen.py: next() for how images are processed for
    # validation - we should do the same thing.
    # numpy_im = img_to_array(im)
    image_batch = np.asarray(im, dtype=K.floatx())
    # I don't see this in datagen.next(), handled by meanstd()? this
    # was probably how the example I was working from normalized.
    # image_batch = image_batch*(1./255)		# normalize to (0, 1.0)

    image_batch = resize_and_crop(image_batch, resize_dim)
    image_batch = meanstd(image_batch, mean, std)
    image_batch = center_crop(image_batch, crop_dim)
    if K.image_data_format() == 'channels_first':
        image_batch = image_batch.transpose(2, 0, 1)

    # Really just an image here - this adds an extra dimension to
    # match what model.predict() expects.
    image_batch = np.expand_dims(image_batch, axis=0)
    predictions = model.predict(image_batch)
    # predictions will be a list of "probabilities" that the image
    # falls into each possible category
    # print(predictions)
    idx = np.argmax(predictions[0])
    prob = predictions[0, idx]
    # print(categories[idx] + '(' + str(prob) + ')' +
    #      ' -- ' + str(positive_id_threshold))

    if prob >= positive_id_threshold:
        cat = categories[idx]
    else:
        cat = 'unknown'

    print(fn + ' -- category: ' + cat + '  prob: ' + str(prob))
    return idx, cat, prob


def predict_all_imgs(im_folder, model, data_module, categories,
                     positive_id_threshold):
    """
    Predict categories for all images in a folder.

    Returns paths, categories and probabilities for all image filenames
    in im_folder.

    Args:
    im_folder: path to a folder containing image files to classify.
    model: model with which to make decode_predictions.
    data_module: data module used to train model
    categories: list of category label_names

    Returns:
    A tuple of file paths, corresponding labels, label names, and
    probabilities generated by the model for each image file.

    """
    print('Classifying from folder ' + im_folder)

    filepaths = []
    labels = []
    label_names = []
    probs = []

    for root, dirnames, filenames in os.walk(im_folder):
        # im_folder should just contain images, not subfolders
        # consider each file in the im_folder
        for f in filenames:
            if re.search(r'(?i)\.(jpg|png|jpeg)$', f):
                filepath = os.path.join(root, f)
                filepaths.append(filepath)

                # Generate prediction for the image
                idx, cat, prob = predict_img(filepath, model, data_module,
                                             categories, positive_id_threshold)

                # The classifier will never produce an index corresponding
                # to 'unknown', we have to fix that up when we have
                # decided that the certainty isn't high enough to
                # decide which category an image belongs to.
                if cat == 'unknown':
                    idx = len(categories)-1

                labels.append(idx)
                label_names.append(cat)
                probs.append(prob)

                # print(f + ': ' + cat + ' (' + str(prob) + ')')

    return filepaths, labels, label_names, probs


def copy_to_folders(result_dir, filepaths, labels, category_names, probs):
    """
    Copy classified images to appropriate folders.

    Move classified image files to a folder structure using category
    names as subfolder names.

    Args:
    result_dir: path to top-level results directory.
    filepaths: list of paths to classified image files.
    labels: corresponding labels for each file path in filepaths.
    category_names: list of possible category names; a folder will be set
        up for each of these.

    Returns: no returned values
    """
    if not os.path.exists(result_dir):
        os.mkdir(result_dir)

    # Set up a log file to record the categories/probabilities for
    # each image file.
    log_file_name = os.path.join(result_dir, 'classification_log.txt')
    log_file = open(log_file_name, 'w')

    # directory now known to exist, create subfolders
    for category in category_names:
        subdir_path = os.path.join(result_dir, category)

        # Take into account that subfolders may also already exist
        if not os.path.exists(subdir_path):
            os.mkdir(subdir_path)

    unknown_subdir = os.path.join(result_dir, 'unknown')
    if not os.path.exists(unknown_subdir):
        os.mkdir(unknown_subdir)

    # Folders for each category now guaranteed to exist in result_dir
    # _copy_data(result_dir, filepaths, labels, category_names)
    for i in xrange(len(filepaths)):
        p, label, prob = filepaths[i], labels[i], probs[i]
        subfolder = os.path.join(result_dir, category_names[label])

        if not os.path.exists(subfolder):
            os.makedirs(subfolder)

        shutil.copy(p, subfolder)

        base, fn = os.path.split(p)
        outstr = fn + ',' + category_names[label] + ',' + str(prob) + '\n'
        # print(outstr)
        log_file.write(outstr)

    log_file.close()


def get_category_names(category_file):
    """Retrieve category names from a text file."""
    f = open(category_file, 'r')
    lines = f.read().split('\n')
    f.close()

    return lines


def main():
    """Predict categories of a file or a folder of files."""
    parser = argparse.ArgumentParser()
    parser.add_argument('name',
                        help='Path name for file or folder to predict')
    parser.add_argument('data', action='store',
                        help='the python data configuration file to use')
    parser.add_argument('--type',
                        help='"file" if first arg is a file name,' +
                        ' "folder" if it is a folder name',
                        choices=['file', 'folder'],
                        default='file')
    parser.add_argument('--classifier',
                        help='path to file containing classifier to use,' +
                        ' in hdf5 format',
                        default='classifier.hdf5')
    parser.add_argument('--target_width',
                        help='target starting width for images to classify',
                        default=342)
    parser.add_argument('--target_height',
                        help='target starting height for images to classify',
                        default=256)
    parser.add_argument('--category_file',
                        help='path to file containing category names',
                        default='category_names.txt')
    parser.add_argument('--result_dir',
                        help='path for result folders',
                        default='results')
    parser.add_argument('--positive_id_threshold', type=float,
                        help='images that do not meet this threshold ' +
                        'are classified as "unknown"',
                        default=0.5)

    args = parser.parse_args()

    print('Classifying from ' + args.name + '  pos_id_thresh=' +
          str(args.positive_id_threshold))

    # .py file describing the data to use, incl. path to folder
    data_module = importlib.import_module('data.{}'.format(args.data))

    if keras.backend.backend() == 'tensorflow':
        keras.backend.clear_session()

    model = keras.models.load_model(args.classifier)
    categories = get_category_names(args.category_file)
    categories.append('unknown')

    # print('Categories: ' + str(categories))

    if args.type == 'file':
        predict_img(args.name, model, data_module, categories)
    else:
        filepaths, labels, label_names, probs = \
            predict_all_imgs(args.name, model, data_module, categories,
                             args.positive_id_threshold)
        copy_to_folders(args.result_dir, filepaths, labels,
                        categories, probs)


if __name__ == '__main__':
    main()
